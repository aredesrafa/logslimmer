#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { runLogRecapPipeline } from '../log-recap/pipeline.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const projectRoot = path.resolve(__dirname, '..')

async function main() {
  const inputFile = process.argv[2] || 'inputlmchat.txt'
  const outputFormat = process.argv.includes('--json') ? 'json' : 'markdown'
  const saveIntermediates = process.argv.includes('--debug')

  const inputPath = path.resolve(projectRoot, inputFile)
  if (!fs.existsSync(inputPath)) {
    console.error(`‚ùå File not found: ${inputPath}`)
    process.exit(1)
  }

  const logText = fs.readFileSync(inputPath, 'utf-8')
  if (!logText.trim()) {
    console.error('‚ùå Input file is empty.')
    process.exit(1)
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19)
  const debugDir = path.join(projectRoot, 'debug_outputs')

  console.log('='.repeat(80))
  console.log('LOG RECAP')
  console.log('='.repeat(80))
  console.log(`File: ${inputFile} (${(logText.length / 1024 / 1024).toFixed(2)} MB)`)
  console.log(`Format: ${outputFormat}`)
  console.log(`Debug: ${saveIntermediates ? 'ON' : 'OFF'}`)
  console.log('')

  const result = await runLogRecapPipeline(logText)

  console.log('‚úÖ Recap complete!')
  console.log(`- Reduction: ${result.stats.sizeReduction}%`)
  console.log(`- Tokens (synthetic): ${result.stats.totalTokensUsed}`)
  console.log(`- Time: ${(result.stats.processingTimeMs / 1000).toFixed(1)}s`)
  console.log('')

  if (saveIntermediates) {
    if (!fs.existsSync(debugDir)) {
      fs.mkdirSync(debugDir, { recursive: true })
    }
    saveDebug(`${timestamp}_timeline.json`, result.events, debugDir)
    saveDebug(`${timestamp}_chunk_summaries.json`, result.chunkSummaries, debugDir)
    saveDebug(`${timestamp}_digest.json`, result.digest, debugDir)
    saveDebug(`${timestamp}_final_summary.md`, result.compressed, debugDir)
  }

  const baseName = path.basename(inputFile, path.extname(inputFile))
  let outputPath
  if (outputFormat === 'json') {
    outputPath = path.join(projectRoot, `LOG_RECAP_${baseName}_${timestamp}.json`)
    fs.writeFileSync(outputPath, JSON.stringify(result, null, 2), 'utf-8')
  } else {
    outputPath = path.join(projectRoot, `LOG_RECAP_${baseName}_${timestamp}.md`)
    fs.writeFileSync(outputPath, formatCliOutput(result), 'utf-8')
  }

  console.log(`üíæ Saved to ${outputPath}`)
  console.log('='.repeat(80))
}

function saveDebug(filename, payload, dir) {
  const filepath = path.join(dir, filename)
  const content = typeof payload === 'string' ? payload : JSON.stringify(payload, null, 2)
  fs.writeFileSync(filepath, content, 'utf-8')
  console.log(`   ‚öôÔ∏è  ${filename}`)
}

function formatCliOutput(result) {
  const lines = []
  lines.push(result.compressed.trim())
  lines.push('')
  if (result.chunkSummaries?.length) {
    lines.push('## Block Overview\n')
    result.chunkSummaries.forEach((summary, idx) => {
      lines.push(`### Chunk ${idx + 1}`)
      lines.push(summary.text.trim())
      lines.push('')
    })
  }
  lines.push('---\nGenerated by LogSlimmer')
  return lines.join('\n')
}

main().catch(error => {
  console.error('‚ùå Error:', error)
  process.exit(1)
})
